I"x	<h2 id="querysets-evaluation-and-caching">QuerySets Evaluation and Caching</h2>
<p><br /></p>

<h3 id="orm-의-특징">ORM 의 특징</h3>
<h4 id="lazy-loading-지연호출">Lazy Loading 지연호출</h4>
<p>-&gt; 필요한 시점, 필요한 만큼만 SQL 호출</p>

<h4 id="eagar-loading-즉시-로딩">Eagar Loading 즉시 로딩</h4>
<dl>
  <dt>selected_related</dt>
  <dd>추가 쿼리 X
prefetch_related</dd>
  <dd>추가적인 쿼리에 해당</dd>
</dl>

<hr />

<h3 id="queryset">QuerySet</h3>
<h4 id="쿼리셋-구성요소">쿼리셋 구성요소</h4>
<p>쿼리셋은 호출하고 나면 캐싱되어 그 이후에 사용할 때는 캐시에서 불러와서 사용한다.</p>

<h4 id="prefetch_related">prefetch_related</h4>
<p><code class="language-plaintext highlighter-rouge">filter</code> 는 한 개의 쿼리에 대해 이뤄지기 때문에 추가적인 쿼리인 <code class="language-plaintext highlighter-rouge">perfetch_related</code> 는 <code class="language-plaintext highlighter-rouge">filter</code> 의 적용을 받지 않는다.
<code class="language-plaintext highlighter-rouge">filter</code> 를 사용하게 된다면 추가적으로 <code class="language-plaintext highlighter-rouge">prefetch_related</code> 를 통해 가져오려는 테이블 데이터를 위한 쿼리를 보내 조회하고 <code class="language-plaintext highlighter-rouge">filter</code> 를 통해 가져오려는 테이블 데이터와 조인하며 조건을 걸어 데이터를 가져오는 쿼리 1 개를 더 날리게 된다.</p>

<p><code class="language-plaintext highlighter-rouge">select_related</code> 의 경우에는 <code class="language-plaintext highlighter-rouge">filter</code>를 사용하여 추가적인 조건절을 걸면 되지만 <code class="language-plaintext highlighter-rouge">prefetch_related</code>는 조건절을 걸고싶다면 <code class="language-plaintext highlighter-rouge">prefetch</code>함수를 사용하면 된다.</p>

<h4 id="쿼리셋-작성-순서">쿼리셋 작성 순서</h4>
<p>Model - annotate - select_related - filter - only - prefetch_related
-&gt; 이 쿼리셋 순서가 실제 SQL 의 순서와 가장 유사.
중복으로 데이터베이스를 조회하는 것을 방지하기 위해 <code class="language-plaintext highlighter-rouge">filter()</code>는 <code class="language-plaintext highlighter-rouge">prefetch_related()</code> 앞에 두도록 한다.</p>

:ET