I"S<h1 id="인증">인증</h1>
<p><b class="post-subtitle">Authentication</b></p>
<blockquote>
  <p>유저의 identification 을 확인하는 절차</p>
</blockquote>

<p>회원가입과 로그인 절차에서 유저의 비밀번호를 데이터베이스에 저장하고 이를 확인하는 인증의 과정이 필요합니다. 이 때 유저의 비밀번호를 그대로 데이터베이스에 저장할 경우, 해킹 시 비밀번호가 그대로 노출되며 내부 인력이 유저의 비밀번호를 조회 할 가능성이 있습니다. 이처럼 비밀번호와 관련된 여러가지 보안 상 문제를 방지하기 위하여 암호화하여 저장하고 관리할 필요가 있고 법 규정<sup href="#fn:1">1</sup>으로 이를 강제하고 있습니다.</p>

<p>먼저 회원가입과 로그인의 절차는,</p>
<ol>
  <li>유저가 아이디와 비밀번호를 생성</li>
  <li>유저의 비밀번호를 암호화하여 데이터베이스에 저장</li>
  <li>유저가 아이디와 비밀번호를 입력</li>
  <li>비밀번호를 암호화 한 후 데이터베이스에 저장된 암호화된 비밀번호와 비교 <l style="font-size:14px; color:#aaa">(일치하면 로그인 성공)</l></li>
  <li>로그인에 성공하면 <code class="language-plaintext highlighter-rouge">access token</code>을 전송</li>
  <li>이후 모든 request에 <code class="language-plaintext highlighter-rouge">access token</code>을 함께 전송 -&gt; 인가<sup>2</sup></li>
</ol>

<p>위와 같은 순서로 진행됩니다. 위 과정에서 암호화와 토큰 발행 두 가지의 과정을 통해 인증과 인가를 진행합니다.</p>

<p><br /></p>
<h1 id="비밀번호-암호화">비밀번호 암호화</h1>
<p><code class="language-plaintext highlighter-rouge">해싱(Hashing)</code>과 <code class="language-plaintext highlighter-rouge">암호화(Encryption)</code> 둘 다 데이터 보안을 위해 사용됩니다. 비밀번호를 암호화 하기 위하여 두 가지 방식을 비교해볼 때 가장 큰 차이점은 방향입니다. 
해시 함수는 <strong>일방향 암호화</strong>이며 복호화가 불가능하고 암호화는 <strong>양방향 암호화</strong>로 복호화가 가능합니다. 전자의 경우 주로 데이터의 노출을 막는 데 목적이 있고 후자는 서버와 브라우저의 통신에서 주고 받는 데이터의 암호화에 목적을 두고 있습니다. <strong>비밀번호의 경우 복호화되지 아니하도록 해시를 통해 일방향 암호화</strong>를 합니다.</p>
<ul>
  <li><strong>일방향 알고리즘</strong> : 암호화를 수행하고 복호화를 수행하였을 때 평문 값을 볼 수 있는 것이 아니라, 암호화된 데이터 값을 보여주는 방식. (SEED, ARIA, AES, RSA 등)</li>
  <li><strong>양방향 알고리즘</strong> : 암호화를 수행하고 복호화 하였을 때 평문 값으로 원래 데이터를 보여주는 방식. (SHA 등)</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/26542094/123530948-0f9e3180-d73b-11eb-9e25-7aad910bdc3b.png" alt="암호화 알고리즘" />
<br /></p>
<h2 id="일방향-해시-함수-one-way-hash-function">일방향 해시 함수 (one-way hash function)</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> import hashlib
<span class="o">&gt;&gt;&gt;</span> h <span class="o">=</span> hashlib.sha256<span class="o">()</span>
<span class="o">&gt;&gt;&gt;</span> h.update<span class="o">(</span>b<span class="s2">"test password"</span><span class="o">)</span>
<span class="o">&gt;&gt;&gt;</span> h.hexdigest<span class="o">()</span>
<span class="s1">'0b47c69b1033498d5f33f5f7d97bb6a3126134751629f4d0185c115db44c094e'</span>

<span class="o">&gt;&gt;&gt;</span> h.update<span class="o">(</span>b<span class="s2">"test password 2"</span><span class="o">)</span>
<span class="o">&gt;&gt;&gt;</span> h.hexdigest<span class="o">()</span>
<span class="s1">'55192b4b915c37be114310c37e4736ecdc10117242574283d9aec75c0814542a'</span>
</code></pre></div></div>
<p><img src="img/hashing.png" alt="해시 함수" /></p>

<p>해시 함수는 입력 값의 길이에 상관 없이 고정된 길이의 해시 값(digest)를 생성합니다. 이 때 입력 값이 일부만 변경되더라도 완전히 다른 해시 값을 출력합니다. 또한 위에서 언급하였듯이 복호화 할 수 없습니다.</p>

<h3 id="해시-함수의-문제점">해시 함수의 문제점</h3>
<ul>
  <li>Brute force attack (무차별 대입 공격) : 해시 함수의 본래 목적은 비밀번호 암호화가 아닌 짧은 시간에 데이터를 검색하기 위해 설계되었습니다. 이러한 특징 때문에 해커는 <code class="language-plaintext highlighter-rouge">해킹할 대상의 digest</code>와 <code class="language-plaintext highlighter-rouge">임의의 문자열의 digest</code>를 빠른 속도로 비교하여 비밀번호를 해킹할 수 있고 유저들이 보통 길거나 복잡하지 않는 비밀번호를 사용한다는 것을 노린 공격 기법입니다.</li>
  <li>Rainbow table attack : 미리 해쉬 값을 계산해 놓은 테이블을 <code class="language-plaintext highlighter-rouge">Rainbow table</code>이라고 합니다. 임의의 문자열을 해싱하면 항상 같은 값이 나온다는 특징을 이용한 해킹 기법입니다. 수많은 문자열의 해시 값을 미리 계산해 DB화하여 Rainbow table를 만들고 해킹한 비밀번호를 Rainbow table의 해시 값들과 비교합니다. 유저들이 어렵지 않고 흔하게 사용되는 비밀번호를 사용할 경우 해킹당할 위험이 크고 같은 비밀번호를 가진 다른 유저까지 해킹 당할 위험이 있습니다.</li>
</ul>

<h3 id="해시-함수의-문제점-보완">해시 함수의 문제점 보완</h3>
<p><img src="img/salting.png" alt="salting" /></p>
<ul>
  <li>Key Stretching : 해싱된 digest를 한 번 더 해싱하고 그 결과 값을 또 한 번 더 해싱하고 이 과정을 여러 번 반복하여 Brute force attack을 방지하는 방법입니다.</li>
  <li>Salting : 임의의 문자열 <code class="language-plaintext highlighter-rouge">salt</code>를 사용자의 비밀번호에 덧붙여 해싱합니다. 비밀번호를 그대로 해싱한 digest와 salt를 덧붙인 digest는 완전히 다른 값이 되기 때문에 Rainbow table attack를 방지할 수 있습니다.</li>
</ul>

<h3 id="해시-함수-종류">해시 함수 종류</h3>
<ul>
  <li>PBKDF2 (Password-Based Key Derivation Function) : <a href="https://docs.djangoproject.com/en/2.2/topics/auth/passwords/">Django</a>에서 기본으로 사용 중입니다. salt를 적용한 후 해시 함수의 반복 횟수를 지정할 수 있습니다.</li>
  <li>bcrypt : 처음부터 비밀번호 저장을 목적으로 설계되었고 Key Stretching과 Salting을 구현한 해시 함수입니다. 관련된 라이브러리도 언어 별로 쉽게 찾아볼 수 있습니다.</li>
  <li>scrypt : digest를 생성할 때 메모리 오버헤드를 갖도록 설계되어, brute force attack을 시도할 때 병렬화 처리가 매우 어렵습니다. 만약 구현하려는 시스템이 매우 민감한 정보를 다루고, 보안 시스템을 구현하는 데 많은 비용을 투자할 수 있다면 사용합니다.</li>
</ul>

<p><br /></p>
<h2 id="bcrypt">Bcrypt</h2>

<div class="footnotes">
    <ol id="fn:1">
        <li id="fn:1">
            제 24조(고유식별정보의 처리 제한) ③ 개인정보처리자가 제 1 항 각 호에 따라 고유식별정보를 처리하는 경우에는 그 고유식별정보가 분실﹒도난﹒유출﹒위조﹒변조 또는 훼손되지 아니하도록 대통령령으로 정하는 바에 따라 암호화 등 안전성 확보에 필요한 조치를 하여야 한다.
        </li>
        <li> request를 실행할 수 있는 권한이 있는 유저인지 확인하는 절차. </li>
    </ol>
</div>
:ET